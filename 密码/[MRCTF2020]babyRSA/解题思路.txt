根据主函数可知，首要目的是找到_P和_Q，首先来看_P
可以发现题目已给出P[9],所以直接目的可以手动测试周围素数，直到找到全部（这里是一部分）
这里我们可以得到N
这一句说明我们应该将这个简单RSA解出来，此时按照一般RSA的步骤求得d
这里已经得到N的所有因数，所以此时N的欧拉函数为所有因数减1相乘，即(p1-1)(p2-1)(…)*(p17-1)， 到此得到P的值
*接下来是Q
可以看到的是所有的参数已经给出，但是如果我们按照这个去算会很慢，因为数值是比较大的，所以这里我们用到了快速幂模
Q_1=  103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521
Q_2=  151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743
sub_Q= 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651
def fastExpMod(b, e, m):
    result = 1
    while e != 0:
        if (e&1) == 1:
            # ei = 1, then mul
            result = (result * b) % m
        e >>= 1
        # b, b^2, b^4, b^8, ... , b^(2^n)
        b = (b*b) % m
    return result
_q=fastExpMod(sub_Q,Q_2 , Q_1)
_q=sympy.nextprime(_q)
通过这个得到最终的Q的值
最后按照常规RSA的解密，完成此题
运行exp.py得到：
b'MRCTF{sti11_@_b@by_qu3st10n}'，即flag：
flag{sti11_@_b@by_qu3st10n}