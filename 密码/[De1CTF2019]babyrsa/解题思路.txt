最上面一层给了4组n和c，中国剩余定理估计是八九不离十了
运行exp1.py得到：
109935857933867829728985398563235455481120300859311421762540858762721955038310117609456763338082237907005937380873151279351831600225270995344096532750271070807051984097524900957809427861441436796934012393707770012556604479065826879107677002380580866325868240270494148512743861326447181476633546419262340100453
首先要对ee2=3非常敏感，低加密指数一般是个突破口，再观察tmp和n的相对大小，发现tmp的3次方与n大小相当
已知
k*n+ce2=(e2+tmp)**3
那么就可以爆破k的大小来获取e2
根据经验来说e2一般不是一个太大的数，输出有很多，从正到负都有，我们想要的就是输出刚刚从负变正的时候对应的e2
运行exp.py2得到其中：
-7103771558034172842883717281653126257401135837570120680226203934406565315867121040264703238744702091280351994240415302654524462159131419203300686938463811124963288687331426021805656686337702761516264035
381791429275130
7103654756784326249785411235218847534005848152323529093095332173072865409872759570762932439780444607879985768816593053888026758840250703720376174706045754848497432831228099290872864606596672137159852622
易得
e2=381791429275130
随后是解e1：
仔细观察可以发现ce1的值与n的值相差了数十个数量级，从概率统计的意义上讲，如果比n小的每个数作为结果的可能相同，那么这种事情发生的概率非常小，但是还有一种可能就是，由于e1很小，e1的42次方都比n小，从而导致模n没起效果。
我们试着给ce1开42次方，果然直接得到一个差不多的整数，证实了猜想。
e1=15218928658178
本来这个问题p，q1，q2，e1，e2都知道，解flag出来是分分钟的事，不过一旦e1，e2和phi1和phi2不互质了问题就复杂起来了，因为这样就没法正常地求私钥d了。
一般来说遇到这种情况都是让e除去其与欧拉函数的最大公约数，让这两个数重新互质，然后求m**gcd（e，phi）的值。
这个问题碰巧a=b=14,那么最后就求出来了m**14相关的两个式子，这个幂次还是有点高，不好处理。
这里就有很巧妙的一招可以把复杂度降下来：
两个式子其实可以用中国剩余定理求m**14，为了使求出来的数尽可能小我们采用：
m14 ☰a1 mod p
m14 ☰ a1 mod q1
m14 ☰ a2 mod p
m 14 ☰ a2 mod q2
然后用求出来的(m**2)**7%（q1*q2）组成一个新的RSA解密，e=7，n=q1*q2
但是用这个实际操作的时候就发现
那么可以直接用第二和第四两个式子求出x(m**2)
运行exp3.py得到：
b'de1ctf{9b10a98b-71bb-4bdf-a6ff-f319943de21f}'
即：flag{9b10a98b-71bb-4bdf-a6ff-f319943de21f}