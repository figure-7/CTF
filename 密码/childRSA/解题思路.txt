这一道RSA打开加密算法乍一看感觉没有问题，N特别大，除了p和q的生成算法啥都没给，
查了一下 Crypto.Util.number 中的sieve_base，发现这是前10000个素数的生成列表，我们再去查一下第10000个素数的值为104729
不过就算我们知道了这个值的大小似乎还是得不到结果，从这个p，q的生成算法中，我们可以知道其是由小于104729的素数随机组合生成的.
为小于p的任何数的倍数，即我们可以将这10000个素数乘起来就为p-1的倍数，于是尝试用费马小定理，即是a^(t*(p-1))-1为p的倍数，t*（p-1)通过上述算法得出即可
运行脚本exp.py得到结果：
178449493212694205742332078583256205058672290603652616240227340638730811945224947826121772642204629335108873832781921390308501763661154638696935732709724016546955977529088135995838497476350749621442719690722226913635772410880516639651363626821442456779009699333452616953193799328647446968707045304702547915799734431818800374360377292309248361548868909066895474518333089446581763425755389837072166970684877011663234978631869703859541876049132713490090720408351108387971577438951727337962368478059295446047962510687695047494480605473377173021467764495541590394732685140829152761532035790187269724703444386838656193674253139
4e4354467b54683372335f6172335f316e7333637572655f5253415f6d3064756c695f376861745f61745f66317273745f676c346e63655f6170706534725f74305f62655f7333637572337d
将输出的16进制数转换为ASCII得到：
NCTF{Th3r3_ar3_1ns3cure_RSA_m0duli_7hat_at_f1rst_gl4nce_appe4r_t0_be_s3cur3}
即flag：
flag{Th3r3_ar3_1ns3cure_RSA_m0duli_7hat_at_f1rst_gl4nce_appe4r_t0_be_s3cur3}